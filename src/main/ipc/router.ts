import { ipcMain, IpcMainInvokeEvent, WebContents } from 'electron'
import { applyMiddlewares, IpcMiddleware } from './middleware'
import { SessionStore } from './protected/session-store'
import fs from 'fs'
import path from 'path'

export type IpcContext = {
  event: IpcMainInvokeEvent
  senderId: number
  webContents: WebContents
  session?: unknown
  user?: unknown
  sessionStore?: SessionStore
}

export type IpcHandler<Args = unknown, Result = unknown> = (
  ctx: IpcContext,
  args: Args
) => Promise<Result> | Result

type RouteMeta = {
  path: string
  handler: IpcHandler
}

export class IpcRouter {
  private sessionStore?: SessionStore
  private routes: Map<string, RouteMeta> = new Map()

  constructor(opts?: { sessionStore?: SessionStore }) {
    this.sessionStore = opts?.sessionStore
  }

  register<Args = unknown, Result = unknown>(
    channel: string,
    middlewares: IpcMiddleware<Args, Result, Result>[] = [],
    handler: IpcHandler<Args, Result>
  ) {
    if (this.routes.has(channel)) {
      console.warn(`[ipc] Channel already registered: ${channel}`)
      return
    }

    const final = applyMiddlewares<Args, Result>(...middlewares)(handler)
    // @ts-ignore (we know the type is correct)
    this.routes.set(channel, { path: channel, handler: final })

    ipcMain.handle(channel, async (event, args) => {
      const ctx: IpcContext = {
        event,
        senderId: event.sender.id,
        webContents: event.sender,
        sessionStore: this.sessionStore
      }

      if (this.sessionStore && (args as any)?.token) {
        const s = this.sessionStore.get((args as any).token)
        if (s) {
          ctx.session = s
          ctx.user = { id: s.userId }
        }
      }

      return final(ctx, args)
    })
  }

  /** Return a nested namespace tree for preload */
  getNamespaceTree() {
    const tree: any = {}
    for (const key of this.routes.keys()) {
      const parts = key.split(':')
      let current = tree
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i]
        if (!current[part]) current[part] = i === parts.length - 1 ? true : {}
        current = current[part]
      }
    }
    return tree
  }
  generatePreloadTypes() {
    const buildTree = (channels: string[]) => {
      const tree: any = {}
      for (const ch of channels) {
        const parts = ch.split(':')
        let node = tree
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i]
          if (i === parts.length - 1) node[part] = true
          else node = node[part] ||= {}
        }
      }
      return tree
    }

    const renderTree = (tree: any, indent = 4): string => {
      const space = ' '.repeat(indent)
      return Object.entries(tree)
        .map(([key, value]) => {
          if (value === true) return `${space}${key}: (args?: any) => Promise<any>`
          const inner = renderTree(value, indent + 2)
          return `${space}${key}: {\n${inner}\n${space}}`
        })
        .join('\n')
    }
    const channels = Array.from(this.routes.values()).map((r) => r.path)
    const tree = buildTree(channels)

    const content = `// AUTO-GENERATED FILE (runtime)
// Generated by IpcRouter
declare global {
  interface Window {
    api: {
${renderTree(tree, 6)}
    }
  }
}
export {}
`

    const file = path.resolve('src/preload/ipc-channels.d.ts')
    fs.writeFileSync(file, content)
    console.log('[ipc] Generated runtime type:', file)

    // Also emit a JSON file for preload to consume at runtime
    const jsonFile = path.resolve(__dirname, '../preload/ipc-channels.json')
    fs.writeFileSync(jsonFile, JSON.stringify(tree, null, 2))
    console.log('[ipc] Generated runtime JSON:', jsonFile)
  }
}
